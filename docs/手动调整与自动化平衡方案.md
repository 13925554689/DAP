# DAP审计系统 - 手动调整与自动化平衡方案

## 📋 核心设计理念

```
审计软件的黄金法则:
┌────────────────────────────────────────────────┐
│  自动化提供效率，手动控制保证质量              │
│  系统负责重复性工作，人负责专业判断            │
│  AI辅助识别问题，审计师做最终决策              │
└────────────────────────────────────────────────┘
```

---

## 一、为什么必须保留手动功能？

### 1.1 审计的专业判断本质

**审计工作 ≠ 数据处理**

```
审计的三个核心要素:
1. 专业怀疑态度 (Professional Skepticism)
   └─ 机器无法实现的批判性思维

2. 职业判断 (Professional Judgment)
   └─ 基于经验和准则的灵活决策

3. 审计证据链 (Audit Evidence Trail)
   └─ 需要人工验证证据的充分性和适当性

结论: 自动化可以提高效率,但不能替代专业判断
```

**实际案例**:
```
案例: 应收账款坏账准备审计

❌ 纯自动化方案:
系统自动计算: 账龄超过1年的应收款 × 50% = 坏账准备
问题: 未考虑客户信用、历史回款情况、担保等因素

✅ 自动化+手动方案:
1. 系统自动计算初步坏账准备
2. 审计师复核并调整:
   ├─ A客户: 虽账龄2年,但有银行保函,调减坏账准备
   ├─ B客户: 账龄半年,但已进入破产程序,调增坏账准备
   └─ 手动填写调整理由和证据
```

### 1.2 数据异常与特殊情况

**现实世界的复杂性**

```
财务数据的7大异常场景:

1. 科目映射错误
   例: "其他应收款-张三" 自动映射为往来款
   实际: 这是股东借款,应重分类为"其他权益工具投资"

2. 金额异常但合理
   例: 银行存款突增1000万
   系统: 标记为异常
   实际: IPO募集资金到账,需手动确认无误

3. 内部交易识别误判
   例: "A公司应收B公司" vs "B公司应付A公司"
   系统: 自动匹配抵消
   实际: A/B是不同集团的同名公司,不应抵消

4. 合并范围边界情况
   例: 持股51%的公司
   系统: 自动纳入合并
   实际: 协议约定无控制权,需手动排除

5. 特殊会计处理
   例: 售后回购交易
   系统: 按销售收入+应收账款处理
   实际: 应按融资处理,需手动调整分录

6. 跨期调整
   例: 跨年度费用分摊
   系统: 按发票日期入账
   实际: 需按权责发生制手动调整

7. 会计估计变更
   例: 固定资产折旧年限调整
   系统: 按原折旧率计算
   实际: 需手动调整折旧政策并重算
```

### 1.3 监管准则要求

**中国注册会计师审计准则的强制要求**

```sql
准则1401号 - 对舞弊的考虑:
"审计师应对管理层凌驾于控制之上的风险实施审计程序"
└─ 含义: 必须人工检查异常交易,不能完全信任系统数据

准则1211号 - 审计证据:
"审计工作底稿应当记录审计师的职业判断"
└─ 含义: 底稿中必须有CPA的判断说明,不能全是系统自动填写

准则1301号 - 审计证据:
"审计师应获取充分、适当的审计证据"
└─ 含义: 自动生成的数据需要验证,必要时手动补充

准则1231号 - 重要性:
"审计师应运用职业判断确定重要性水平"
└─ 含义: 重要性判断无法自动化,需要手动设定和调整
```

### 1.4 客户个性化需求

**一企一策的审计策略**

```
制造业客户:
├─ 存货: 需要详细的成本归集底稿
│   ├─ 材料成本明细表
│   ├─ 人工成本分配表
│   ├─ 制造费用分摊表
│   └─ 完工百分比法计算底稿
└─ 手动需求: 需要根据生产工艺自定义底稿模板

房地产客户:
├─ 存货: 开发产品,需要项目制核算
│   ├─ 开发成本归集表
│   ├─ 预售款与已售面积匹配表
│   ├─ 完工进度确认底稿
│   └─ 收入确认时点判断说明
└─ 手动需求: 需要针对每个项目单独编制底稿

金融机构:
├─ 金融资产: IFRS 9分类
│   ├─ 金融资产分类明细
│   ├─ 预期信用损失模型
│   ├─ 公允价值估值底稿
│   └─ 减值测试计算表
└─ 手动需求: 复杂估值模型需要手动调整参数

结论: 标准模板无法覆盖所有行业,必须支持手动定制
```

---

## 二、各环节的手动调整需求分析

### 2.1 项目管理阶段

#### **自动化功能**
```
✅ 项目创建: 基于模板自动创建项目
✅ 会计期间: 自动识别财务年度
✅ 审计组: 自动分配默认角色
```

#### **手动调整需求** ⭐⭐⭐ (重要)
```
场景1: 项目信息修正
├─ 需求: 客户名称变更、会计期间调整、审计类型切换
├─ 理由: 项目启动后可能发生变化
└─ 方案: 提供项目信息编辑界面,支持修改所有字段

场景2: 审计组调整
├─ 需求: 增减审计组成员、变更复核人、调整角色权限
├─ 理由: 人员变动、工作量调整
└─ 方案: 提供审计组管理界面,支持动态调整

场景3: 集团架构调整
├─ 需求: 添加/删除实体、修改层级关系、调整持股比例
├─ 理由: 集团重组、股权变更、新设/注销子公司
└─ 方案: 提供可视化层级编辑器,支持拖拽调整
```

**界面设计**:
```
┌─────────────────────────────────────────────────┐
│  项目信息编辑                          [保存][取消]│
├─────────────────────────────────────────────────┤
│  项目名称: [集团A 2024年度审计________] 🔓编辑   │
│  会计期间: [2024-01-01] 至 [2024-12-31]         │
│  审计类型: ☑ 年报审计 ☐ IPO审计 ☐ 专项审计      │
│                                                  │
│  集团架构: [编辑层级▼]                           │
│  ┌──────────────────────────────────┐          │
│  │ 📂 集团A总部                      │          │
│  │   ├─ 🏢 子公司1 (100%) [删除][编辑]│          │
│  │   ├─ 🏢 子公司2 (60%)  [删除][编辑]│          │
│  │   │   └─ 🏪 孙公司2-1 (51%)       │          │
│  │   └─ [+ 添加子公司]               │          │
│  └──────────────────────────────────┘          │
│                                                  │
│  审计组成员: [管理成员▼]                         │
│  ├─ 合伙人: 王五 [更换]                          │
│  ├─ 项目经理: 李四 [更换]                        │
│  └─ 审计员: 张三、赵六 [添加][移除]              │
└─────────────────────────────────────────────────┘
```

---

### 2.2 数据导入与清洗阶段

#### **自动化功能**
```
✅ 数据导入: 支持800+财务软件
✅ 科目映射: AI自动识别映射
✅ 数据清洗: 自动去重、补齐
✅ 账表核对: 自动核对科目余额表与总账
```

#### **手动调整需求** ⭐⭐⭐⭐⭐ (非常重要)
```
场景1: 科目映射修正
├─ 问题: AI映射错误率5-10%
├─ 需求: 手动修正映射关系
└─ 方案: 提供科目映射审核界面

场景2: 数据异常处理
├─ 问题: 金额异常、借贷不平、科目不存在
├─ 需求: 人工判断是否需要调整
└─ 方案: 提供异常数据审核列表,支持忽略/修正/退回

场景3: 重分类调整
├─ 问题: 系统按科目编码分类,但需要按性质重分类
├─ 例子: "预付账款-贷方" 应重分类为 "预收账款"
└─ 方案: 提供重分类调整界面

场景4: 手动补充数据
├─ 问题: 财务软件未导出的辅助核算信息
├─ 例子: 应收账款的客户明细、存货的仓库位置
└─ 方案: 提供Excel批量导入+手动录入
```

**界面设计**:
```
┌────────────────────────────────────────────────────────┐
│  科目映射审核                    [批量确认] [导出] [保存]│
├────────────────────────────────────────────────────────┤
│  筛选: ☑ 仅显示异常 ☐ 显示全部  置信度: [<80%▼]       │
├────────────────────────────────────────────────────────┤
│序号│源科目编码│源科目名称│AI映射结果│置信度│操作       │
├───┼─────────┼─────────┼─────────┼─────┼───────────┤
│1  │1122.01   │其他应收款-│1122其他  │ 95% │ ✅ [修改] │
│   │          │张三       │应收款    │     │           │
├───┼─────────┼─────────┼─────────┼─────┼───────────┤
│2  │6602.05   │销售费用-  │6602销售  │ 72% │ ⚠️ [修改] │
│   │          │广告宣传费 │费用      │     │           │
│   │          │           │          │     │  建议: 明细科目 │
│   │          │           │          │     │  6602.02广告费│
├───┼─────────┼─────────┼─────────┼─────┼───────────┤
│3  │5403      │不明科目   │无匹配    │  0% │ ❌ [手动选择]│
└───┴─────────┴─────────┴─────────┴─────┴───────────┘

【修改映射对话框】
┌──────────────────────────────────────┐
│  修改科目映射                   [×]  │
├──────────────────────────────────────┤
│  源科目: 6602.05 销售费用-广告宣传费  │
│                                      │
│  AI建议: 6602 销售费用 (置信度72%)   │
│                                      │
│  手动选择: [搜索科目...]             │
│  ┌────────────────────────────┐     │
│  │ 🔍 输入科目编码或名称...   │     │
│  │                            │     │
│  │ 匹配结果:                  │     │
│  │ ☑ 6602.02 广告费           │     │
│  │ ☐ 6602.03 业务宣传费       │     │
│  │ ☐ 6602.05 展览费           │     │
│  └────────────────────────────┘     │
│                                      │
│  备注: [广告费明细科目]              │
│                                      │
│  [取消]  [应用到同类科目]  [确定]    │
└──────────────────────────────────────┘
```

---

### 2.3 审计底稿编制阶段

#### **自动化功能**
```
✅ 底稿创建: 从模板自动创建
✅ 数据填写: 自动从数据库取数
✅ 索引号: 自动生成和关联
✅ 计算公式: 自动计算合计、勾稽
```

#### **手动调整需求** ⭐⭐⭐⭐⭐ (最重要)
```
场景1: 底稿内容修改
├─ 问题: 自动填写的数据需要验证和调整
├─ 需求: 直接在Excel中编辑单元格
└─ 方案: 提供在线Excel编辑器,保留编辑痕迹

场景2: 添加附件和说明
├─ 问题: 需要补充银行对账单、合同等附件
├─ 需求: 上传扫描件、添加文字说明
└─ 方案: 提供附件管理和文本编辑功能

场景3: 自定义底稿模板
├─ 问题: 标准模板不适用特殊行业
├─ 需求: 修改模板格式、增删列
└─ 方案: 提供模板编辑器,支持另存为新模板

场景4: 测试数据录入
├─ 问题: 穿行测试、抽样测试的样本信息
├─ 需求: 手动录入测试过程和结论
└─ 方案: 提供结构化表单录入

场景5: 审计调整分录
├─ 问题: 发现错误需要建议调整
├─ 需求: 手动编制调整分录
└─ 方案: 提供调整分录编辑界面
```

**界面设计**:
```
┌─────────────────────────────────────────────────────────┐
│  审计底稿编辑器 - A-1-02 应收账款函证                    │
├─────────────────────────────────────────────────────────┤
│  [文件] [编辑] [插入] [审阅] [数据] [公式] [帮助]        │
├─────────────────────────────────────────────────────────┤
│  💾自动保存    🔒锁定保护    📋复制    ✂️剪切    📌粘贴 │
│  ↩️撤销      ↪️重做       🔍查找    📝批注    🖨️打印  │
├─────────────────────────────────────────────────────────┤
│                                                          │
│  [Excel在线编辑区域]                                     │
│  ┌──────┬───────────┬──────────┬─────────┬──────┐    │
│  │ 序号 │ 客户名称   │ 账面余额  │ 函证金额 │ 差异 │    │
│  ├──────┼───────────┼──────────┼─────────┼──────┤    │
│  │  1   │ A客户      │ 1,000,000│ 1,000,000│  0   │✅  │
│  │  2   │ B客户      │   500,000│   480,000│20,000│⚠️  │
│  │  3   │ C客户      │   300,000│ [手动填写]│ [自动]│   │
│  ├──────┼───────────┼──────────┼─────────┼──────┤    │
│  │ 合计 │            │=SUM(C2:C4)│=SUM(D2:D4)│=SUM(E2:E4)│
│  └──────┴───────────┴──────────┴─────────┴──────┘    │
│                                                          │
│  差异说明:                                               │
│  ┌──────────────────────────────────────────┐          │
│  │ B客户差异20,000元系对方已付款,我方未      │          │
│  │ 记账,已建议调整分录。                    │          │
│  │ 支持证据: 见附件-银行回单20241120.pdf    │          │
│  └──────────────────────────────────────────┘          │
│                                                          │
│  附件 (2个): 📄函证回函.pdf  📄银行回单.pdf              │
│  [+ 上传附件] [查看全部]                                 │
│                                                          │
│  建议调整分录:                                           │
│  借: 银行存款 20,000                                     │
│      贷: 应收账款-B客户 20,000                           │
│  [添加调整分录]                                          │
├─────────────────────────────────────────────────────────┤
│  编辑历史: 张三 2024-11-20 15:30 修改了C3单元格         │
│           李四 2024-11-21 09:15 添加了差异说明          │
└─────────────────────────────────────────────────────────┘
```

---

### 2.4 合并报表与抵消分录阶段

#### **自动化功能**
```
✅ 合并范围: 自动确定需要合并的实体
✅ 抵消识别: AI自动识别内部往来
✅ 抵消分录: 按八大步骤自动生成
✅ 合并计算: 自动汇总各实体数据
```

#### **手动调整需求** ⭐⭐⭐⭐⭐ (非常重要)
```
场景1: 合并范围调整
├─ 问题: 系统按持股比例判断,但实际需考虑实质控制
├─ 需求: 手动调入/调出合并范围
└─ 方案: 提供合并范围勾选界面

场景2: 抵消分录修改
├─ 问题: AI识别准确率85-90%,需要人工确认
├─ 需求: 修改抵消金额、调整分录、删除错误匹配
└─ 方案: 提供抵消分录审核编辑界面

场景3: 手动添加抵消分录
├─ 问题: 特殊交易AI无法识别(如股权激励、关联租赁)
├─ 需求: 手动编制抵消分录
└─ 方案: 提供抵消分录录入表单

场景4: 少数股东权益调整
├─ 问题: 系统按持股比例自动计算,但需考虑优先股等特殊权益
├─ 需求: 手动调整少数股东权益比例
└─ 方案: 提供少数股东权益明细编辑界面

场景5: 商誉与合并差额调整
├─ 问题: 收购日公允价值需要专业评估
├─ 需求: 手动输入评估结果
└─ 方案: 提供商誉计算底稿编辑界面
```

**界面设计**:
```
┌───────────────────────────────────────────────────────────┐
│  抵消分录工作底稿                      [自动生成] [手动添加]│
├───────────────────────────────────────────────────────────┤
│  合并主体: 集团A    期间: 2024年度    合并方式: 整体合并   │
├───────────────────────────────────────────────────────────┤
│  ✅ 1. 长期股权投资抵消 (系统自动 - 3条)  [查看] [编辑]   │
│  ✅ 2. 内部往来抵消 (系统自动 - 12条)     [查看] [编辑]   │
│  ⚠️ 3. 内部销售抵消 (系统自动 - 5条)     [查看] [编辑]   │
│      └─ 发现2条可能误判,需人工确认 👉 [立即审核]         │
│  ✅ 4. 固定资产交易抵消 (系统自动 - 2条)  [查看] [编辑]   │
│  ✅ 5. 盈余公积调整 (系统自动 - 3条)      [查看] [编辑]   │
│  📝 6. 关联租赁抵消 (手动添加 - 1条)      [查看] [编辑]   │
├───────────────────────────────────────────────────────────┤
│  抵消分录明细 (内部销售抵消 - 5条):                       │
│                                                            │
│  序号  类型    交易对    借方科目  借方金额  贷方科目  贷方金额  状态│
│  E-01  销售    母→子1    营业收入  5,000,000 营业成本  5,000,000 ✅│
│  E-02  销售    母→子2    营业收入  3,000,000 营业成本  3,000,000 ✅│
│  E-03  销售    子1→子2   营业收入  2,000,000 营业成本  2,000,000 ⚠️│
│        └─ 警告: 子1与子2是平级,请确认是否存在内部销售         │
│           [确认无误] [删除此条] [修改金额]                     │
│  E-04  存货利润 母→子1   营业成本    800,000 存货        800,000 ✅│
│  E-05  存货利润 母→子2   营业成本    400,000 存货        400,000 ✅│
│                                                            │
│  [+ 手动添加抵消分录]                                      │
└───────────────────────────────────────────────────────────┘

【手动添加抵消分录】
┌──────────────────────────────────────────┐
│  手动抵消分录编制                   [×]  │
├──────────────────────────────────────────┤
│  抵消类型: [关联租赁▼]                   │
│            (选项: 内部往来/内部销售/      │
│             固定资产/无形资产/其他)       │
│                                          │
│  交易对: [母公司▼] → [子公司1▼]          │
│                                          │
│  借方科目: [6602.10▼] 租赁费用           │
│  借方金额: [1200000.00]                  │
│                                          │
│  贷方科目: [6001.08▼] 租金收入           │
│  贷方金额: [1200000.00]                  │
│                                          │
│  抵消说明:                               │
│  ┌────────────────────────────┐        │
│  │母公司将办公楼租给子公司1,   │        │
│  │年租金120万元,需抵消内部租赁  │        │
│  │收支。支持证据见附件。        │        │
│  └────────────────────────────┘        │
│                                          │
│  附件: [上传租赁合同]                    │
│                                          │
│  [取消]  [保存草稿]  [确认添加]          │
└──────────────────────────────────────────┘
```

---

### 2.5 分级复核阶段

#### **自动化功能**
```
✅ 复核流转: 自动流转到复核人
✅ 检查项: 自动检查底稿完整性
✅ 通知提醒: 自动发送复核通知
```

#### **手动调整需求** ⭐⭐⭐⭐ (很重要)
```
场景1: 添加复核意见
├─ 问题: 发现底稿问题需要反馈
├─ 需求: 添加批注、提问、建议
└─ 方案: 提供批注系统

场景2: 退回修改
├─ 问题: 底稿不符合要求
├─ 需求: 退回编制人,说明原因
└─ 方案: 提供退回流程和意见填写

场景3: 跨底稿追踪
├─ 问题: 需要查看关联底稿
├─ 需求: 点击索引号跳转
└─ 方案: 实现底稿超链接

场景4: 复核结论
├─ 问题: 需要给出专业判断
├─ 需求: 选择复核结论并签字
└─ 方案: 提供结构化复核表单
```

**界面设计**:
```
┌────────────────────────────────────────────────────────┐
│  底稿复核 - A-1-02 应收账款函证              [项目经理]  │
├────────────────────────────────────────────────────────┤
│  底稿信息:                                              │
│  编制人: 张三    编制日期: 2024-11-20                   │
│  一级复核: 李四(已通过) 2024-11-21                      │
│  二级复核: 等待中 👈 当前                               │
├────────────────────────────────────────────────────────┤
│  自动检查结果:                                          │
│  ✅ 底稿完整性检查通过                                  │
│  ✅ 勾稽关系检查通过                                    │
│  ⚠️ 发现1处需要关注的事项:                             │
│     B客户函证差异20,000元,已提出调整分录但未复核        │
│                                                         │
│  [查看底稿详情]                                         │
├────────────────────────────────────────────────────────┤
│  复核意见: (历史3条)                                    │
│                                                         │
│  💬 李四 (一级复核) 2024-11-21 09:30                    │
│     "B客户函证差异的银行回单扫描不清楚,请重新上传"      │
│     状态: ✅ 已解决 (张三 2024-11-21 14:00)            │
│                                                         │
│  💬 王五 (项目经理) 2024-11-22 10:00 👈 新增           │
│     "请补充C客户的催收记录,评估坏账风险"                │
│     位置: Sheet1!备注栏    [查看]                       │
│                                                         │
│  [添加新批注]                                           │
├────────────────────────────────────────────────────────┤
│  复核结论:                                              │
│  ⚪ 通过          ⚪ 通过(有修改)                        │
│  ⚪ 退回修改      ⚪ 需要补充证据                        │
│                                                         │
│  复核说明: ___________________________________          │
│           |建议补充C客户的催收函件扫描件,  |          │
│           |其余内容符合审计要求。          |          │
│           |_________________________________|          │
│                                                         │
│  电子签名: [王五] 🔏                                    │
│  复核时间: 2024-11-22 10:15                             │
│                                                         │
│  [取消]  [保存草稿]  [提交复核结论]                     │
└────────────────────────────────────────────────────────┘
```

---

### 2.6 索引号管理阶段

#### **自动化功能**
```
✅ 索引生成: 按规则自动生成 (A-1-01, B-2-03...)
✅ 交叉引用: 自动识别相关底稿
```

#### **手动调整需求** ⭐⭐⭐ (重要)
```
场景1: 索引号调整
├─ 问题: 底稿新增或删除导致索引号顺序变化
├─ 需求: 手动重新编号
└─ 方案: 提供索引号批量调整工具

场景2: 自定义索引规则
├─ 问题: 不同事务所有不同的索引编号习惯
├─ 需求: 自定义索引号格式
└─ 方案: 提供索引规则配置

场景3: 手动添加引用
├─ 问题: 需要关联相关底稿
├─ 需求: 手动建立索引链接
└─ 方案: 提供索引关联界面
```

---

### 2.7 穿行测试阶段

#### **自动化功能**
```
✅ 测试模板: 提供标准测试底稿
✅ 样本选择: 系统推荐测试样本
```

#### **手动调整需求** ⭐⭐⭐⭐⭐ (最重要)
```
场景1: 测试过程记录
├─ 问题: 穿行测试必须人工执行
├─ 需求: 记录测试步骤、观察结果、测试结论
└─ 方案: 提供测试过程记录表单

场景2: 控制偏差记录
├─ 问题: 发现内控偏差需要记录
├─ 需求: 描述偏差、评估影响、提出建议
└─ 方案: 提供偏差记录模板

场景3: 测试证据附件
├─ 问题: 需要附上照片、截图、扫描件
├─ 需求: 上传测试证据
└─ 方案: 提供附件管理

注意: 穿行测试是高度人工的过程,无法自动化,必须全程手动记录
```

---

## 三、手动与自动的最优平衡方案

### 3.1 设计原则

```
核心原则:
┌────────────────────────────────────────┐
│  1. 默认自动,允许手动覆盖              │
│  2. 自动化可见,手动可追溯              │
│  3. 关键判断必须人工,常规工作自动化    │
│  4. 系统辅助决策,人拥有最终决定权      │
└────────────────────────────────────────┘
```

### 3.2 具体实施策略

#### **策略1: 三档自动化等级**

```
完全自动化 (无需人工):
├─ 索引号生成
├─ 公式计算
├─ 数据汇总
└─ 报表格式化

半自动化 (AI辅助+人工确认):
├─ 科目映射 (AI建议 → 人工确认)
├─ 内部往来识别 (AI匹配 → 人工审核)
├─ 抵消分录生成 (AI生成 → 人工调整)
└─ 异常检测 (AI标记 → 人工判断)

完全手工 (人工主导):
├─ 穿行测试记录
├─ 重要性判断
├─ 审计意见
├─ 复核结论
└─ 特殊事项说明
```

#### **策略2: 权限分级**

```
审计员:
├─ 可以: 编辑底稿、添加附件、提交复核
└─ 不可以: 修改索引规则、删除他人底稿

项目经理:
├─ 可以: 审计员权限 + 复核通过、调整抵消分录
└─ 不可以: 修改已批准的底稿、删除项目

合伙人:
├─ 可以: 所有权限 + 最终批准、项目归档
└─ 限制: 需要双重验证

系统管理员:
├─ 可以: 技术管理权限
└─ 不可以: 修改审计内容
```

#### **策略3: 审计追踪**

```
必须记录的信息:
┌──────────────────────────────────────┐
│  1. 谁 (Who): 操作人                 │
│  2. 何时 (When): 操作时间            │
│  3. 做了什么 (What): 操作类型        │
│  4. 为什么 (Why): 操作理由           │
│  5. 改了什么 (Change): 修改前后对比  │
└──────────────────────────────────────┘

实现方式:
├─ 数据库层: 记录所有INSERT/UPDATE/DELETE操作
├─ 应用层: 记录业务操作日志
├─ 界面层: 显示修改历史
└─ 导出层: 审计日志可导出

示例:
2024-11-22 10:30:15 | 张三 | 修改底稿A-1-02 单元格C3 |
  修改前: 1,000,000 | 修改后: 980,000 |
  原因: 核对函证回函,发现金额差异
```

#### **策略4: 智能辅助**

```
AI在手动环节的辅助作用:

场景1: 科目映射修正
├─ AI提示: "检测到'其他应收款-张三',是否为关联方交易?"
├─ 建议选项: [是,重分类为关联方往来] [否,保持原科目]
└─ 人工决策: 选择建议或自行判断

场景2: 抵消分录审核
├─ AI分析: "该笔内部销售存在未实现利润800,000元"
├─ 建议分录: 借:营业成本 800,000  贷:存货 800,000
├─ 置信度: 92%
└─ 人工决策: [采纳] [修改金额] [删除] [标记为例外]

场景3: 异常数据标记
├─ AI检测: "B客户应收账款账龄突增,从60天增至180天"
├─ 风险提示: 可能存在坏账风险,建议增加坏账准备
├─ 建议调整: 10% → 30%
└─ 人工判断: 审阅客户信用、历史回款后决定

原则: AI提供建议和依据,最终决策权在审计师
```

---

## 四、具体功能实现设计

### 4.1 通用手动编辑组件

**Excel在线编辑器**
```javascript
// 基于开源组件 (如 handsontable, ag-grid)
class AuditWorkpaperEditor {
    constructor(workpaperId) {
        this.workpaperId = workpaperId;
        this.hotInstance = null;
        this.changeLog = [];
    }

    // 初始化编辑器
    initialize() {
        this.hotInstance = new Handsontable(container, {
            data: this.loadWorkpaperData(),
            colHeaders: true,
            rowHeaders: true,
            contextMenu: true,

            // 单元格编辑
            cells: (row, col) => {
                return {
                    readOnly: this.isCellLocked(row, col),
                    className: this.getCellClass(row, col)
                };
            },

            // 监听变更
            afterChange: (changes) => {
                this.logChanges(changes);
                this.autoSave();
            },

            // 自定义验证
            beforeChange: (changes) => {
                return this.validateChanges(changes);
            }
        });
    }

    // 记录变更
    logChanges(changes) {
        if (!changes) return;

        changes.forEach(([row, prop, oldValue, newValue]) => {
            this.changeLog.push({
                timestamp: new Date().toISOString(),
                user: currentUser.name,
                cell: `R${row}C${prop}`,
                oldValue: oldValue,
                newValue: newValue,
                reason: prompt('请说明修改理由:')  // 强制要求填写理由
            });
        });
    }

    // 单元格锁定逻辑
    isCellLocked(row, col) {
        // 1. 公式单元格锁定(防止误删公式)
        if (this.isFormulaCell(row, col)) return true;

        // 2. 审批后的底稿锁定
        if (this.workpaperStatus === 'approved') return true;

        // 3. 非编制人锁定
        if (this.currentUser !== this.workpaperCreator) return true;

        return false;
    }

    // 自动保存
    autoSave() {
        clearTimeout(this.saveTimer);
        this.saveTimer = setTimeout(() => {
            this.saveToServer();
        }, 3000);  // 3秒后自动保存
    }
}
```

**通用批注组件**
```javascript
class WorkpaperCommentSystem {
    // 添加批注
    addComment(cellRef, commentData) {
        const comment = {
            id: generateUUID(),
            workpaperId: this.workpaperId,
            cellRef: cellRef,  // 如 'Sheet1!A1'
            type: commentData.type,  // question, suggestion, issue
            content: commentData.content,
            createdBy: currentUser.name,
            createdAt: new Date().toISOString(),
            resolved: false
        };

        // 保存到数据库
        this.saveComment(comment);

        // 在界面上显示标记
        this.markCellWithComment(cellRef);

        // 发送通知
        this.notifyWorkpaperOwner(comment);

        return comment;
    }

    // 解决批注
    resolveComment(commentId, resolution) {
        this.updateComment(commentId, {
            resolved: true,
            resolvedBy: currentUser.name,
            resolvedAt: new Date().toISOString(),
            resolution: resolution
        });

        // 移除界面标记
        this.removeCellCommentMark(commentId);
    }

    // 批注对话
    replyToComment(commentId, replyText) {
        this.addReply(commentId, {
            replyBy: currentUser.name,
            replyAt: new Date().toISOString(),
            content: replyText
        });

        // 通知原批注人
        this.notifyCommentAuthor(commentId);
    }
}
```

### 4.2 抵消分录手动编辑

**抵消分录管理器**
```python
class EliminationEntryManager:
    """抵消分录管理 - 支持自动+手动"""

    def review_auto_generated_entries(self, consolidation_id: str) -> Dict:
        """审核自动生成的抵消分录"""

        auto_entries = self.get_auto_generated_entries(consolidation_id)

        return {
            'total': len(auto_entries),
            'categories': self._categorize_entries(auto_entries),
            'confidence_distribution': self._analyze_confidence(auto_entries),
            'review_suggestions': self._generate_review_suggestions(auto_entries)
        }

    def manual_adjust_entry(self, entry_id: str, adjustments: Dict) -> Dict:
        """手动调整抵消分录"""

        original_entry = self.get_entry(entry_id)

        # 记录调整
        adjustment_log = {
            'entry_id': entry_id,
            'original_amount': original_entry['amount'],
            'adjusted_amount': adjustments['amount'],
            'adjustment_reason': adjustments['reason'],
            'adjusted_by': current_user.name,
            'adjusted_at': datetime.now().isoformat()
        }

        # 应用调整
        self.update_entry(entry_id, adjustments)

        # 保存日志
        self.log_adjustment(adjustment_log)

        # 重新计算合并报表
        self.recalculate_consolidated_statements(consolidation_id)

        return {
            'success': True,
            'adjustment_log_id': adjustment_log['id']
        }

    def add_manual_entry(self, entry_data: Dict) -> Dict:
        """手动添加抵消分录"""

        # 验证分录平衡
        if entry_data['debit_amount'] != entry_data['credit_amount']:
            return {
                'success': False,
                'error': '抵消分录不平衡,借贷方金额必须相等'
            }

        # 验证必填字段
        required_fields = ['elimination_type', 'debit_account', 'credit_account',
                          'amount', 'description', 'reason']
        missing = [f for f in required_fields if not entry_data.get(f)]
        if missing:
            return {
                'success': False,
                'error': f'缺少必填字段: {", ".join(missing)}'
            }

        # 创建手工分录
        entry_id = str(uuid.uuid4())
        entry = {
            'entry_id': entry_id,
            'source': 'manual',  # 标记为手工分录
            'confidence': 1.0,    # 手工分录置信度100%
            'created_by': current_user.name,
            'created_at': datetime.now().isoformat(),
            **entry_data
        }

        # 保存分录
        self.save_entry(entry)

        # 更新合并报表
        self.recalculate_consolidated_statements(entry_data['consolidation_id'])

        return {
            'success': True,
            'entry_id': entry_id
        }

    def delete_entry(self, entry_id: str, reason: str) -> Dict:
        """删除抵消分录 (软删除)"""

        entry = self.get_entry(entry_id)

        # 只有自动生成的分录或自己创建的手工分录可以删除
        if entry['source'] == 'auto' or entry['created_by'] == current_user.name:
            self.soft_delete_entry(entry_id, {
                'deleted_by': current_user.name,
                'deleted_at': datetime.now().isoformat(),
                'delete_reason': reason
            })

            return {'success': True}
        else:
            return {
                'success': False,
                'error': '只能删除自己创建的分录'
            }
```

---

## 五、权限与安全控制

### 5.1 细粒度权限设计

```python
class AuditPermissionManager:
    """审计权限管理"""

    # 权限矩阵
    PERMISSIONS = {
        '审计员': {
            'workpaper': ['create', 'edit_own', 'view', 'submit_review'],
            'elimination': ['view'],
            'project': ['view'],
            'review': ['add_comment_to_own']
        },
        '项目组长': {
            'workpaper': ['create', 'edit_own', 'edit_team', 'view', 'submit_review', 'review_L1'],
            'elimination': ['view', 'edit', 'add_manual'],
            'project': ['view', 'edit_team_members'],
            'review': ['add_comment', 'resolve_comment', 'approve_L1']
        },
        '项目经理': {
            'workpaper': ['create', 'edit', 'view', 'review_L2', 'lock'],
            'elimination': ['view', 'edit', 'add_manual', 'delete'],
            'project': ['view', 'edit', 'manage_team'],
            'review': ['add_comment', 'resolve_comment', 'approve_L2', 'reject']
        },
        '合伙人': {
            'workpaper': ['*'],  # 所有权限
            'elimination': ['*'],
            'project': ['*'],
            'review': ['approve_final', 'sign_report']
        }
    }

    def can_edit_workpaper(self, user: User, workpaper: Workpaper) -> bool:
        """检查是否可以编辑底稿"""

        # 规则1: 已批准的底稿不能编辑
        if workpaper.status == 'approved':
            return user.role == '合伙人'

        # 规则2: 只能编辑自己创建的底稿
        if user.role == '审计员':
            return workpaper.created_by == user.id

        # 规则3: 组长可以编辑组内成员的底稿
        if user.role == '项目组长':
            return workpaper.created_by in user.team_members

        # 规则4: 经理和合伙人可以编辑所有底稿
        return user.role in ['项目经理', '合伙人']

    def can_modify_elimination_entry(self, user: User, entry: EliminationEntry) -> bool:
        """检查是否可以修改抵消分录"""

        # 规则1: 自动生成的分录,项目组长及以上可修改
        if entry.source == 'auto':
            return user.role in ['项目组长', '项目经理', '合伙人']

        # 规则2: 手工分录,创建人或更高级别可修改
        if entry.source == 'manual':
            return (entry.created_by == user.id or
                   user.role in ['项目经理', '合伙人'])

        return False
```

### 5.2 审计日志

```python
class AuditTrailLogger:
    """审计追踪日志"""

    def log_modification(self, entity_type: str, entity_id: str,
                        action: str, changes: Dict, reason: str):
        """记录修改日志"""

        log_entry = {
            'log_id': str(uuid.uuid4()),
            'timestamp': datetime.now().isoformat(),
            'user_id': current_user.id,
            'user_name': current_user.name,
            'user_role': current_user.role,
            'entity_type': entity_type,  # 'workpaper', 'elimination_entry'等
            'entity_id': entity_id,
            'action': action,  # 'create', 'update', 'delete', 'approve'
            'changes': json.dumps(changes, ensure_ascii=False),
            'reason': reason,
            'ip_address': request.remote_addr,
            'user_agent': request.user_agent.string
        }

        # 写入审计日志表
        self.save_audit_log(log_entry)

        # 对于敏感操作,额外发送通知
        if action in ['delete', 'approve_final']:
            self.notify_supervisors(log_entry)

    def get_entity_history(self, entity_type: str, entity_id: str) -> List[Dict]:
        """获取实体的完整修改历史"""

        logs = self.query_audit_logs(
            entity_type=entity_type,
            entity_id=entity_id,
            order_by='timestamp DESC'
        )

        return [self._format_log_entry(log) for log in logs]

    def generate_audit_trail_report(self, project_id: str,
                                   start_date: str, end_date: str) -> Dict:
        """生成审计追踪报告"""

        logs = self.query_audit_logs(
            project_id=project_id,
            start_date=start_date,
            end_date=end_date
        )

        return {
            'project_id': project_id,
            'period': f'{start_date} - {end_date}',
            'total_operations': len(logs),
            'by_user': self._group_by_user(logs),
            'by_action': self._group_by_action(logs),
            'by_entity_type': self._group_by_entity_type(logs),
            'sensitive_operations': self._filter_sensitive(logs),
            'detailed_logs': logs
        }
```

---

## 六、用户体验优化

### 6.1 智能提示与建议

```python
class IntelligentAssistant:
    """智能助手 - 在手动操作时提供建议"""

    def suggest_on_mapping_edit(self, account_code: str, account_name: str) -> Dict:
        """科目映射时的智能建议"""

        # 1. 相似科目查找
        similar_accounts = self.find_similar_accounts(account_name, limit=5)

        # 2. 历史映射记录
        historical_mappings = self.get_historical_mappings(
            account_code_pattern=account_code[:4]  # 前4位编码
        )

        # 3. AI语义分析
        ai_suggestions = self.ai_analyze_account_name(account_name)

        return {
            'similar_accounts': similar_accounts,
            'historical_mappings': historical_mappings,
            'ai_suggestions': ai_suggestions,
            'confidence_scores': self._calculate_confidence(similar_accounts)
        }

    def suggest_on_elimination_edit(self, transaction: Dict) -> Dict:
        """编辑抵消分录时的建议"""

        # 1. 检查是否有类似的历史抵消
        similar_eliminations = self.find_similar_eliminations(transaction)

        # 2. 检查是否遗漏相关抵消
        related_eliminations = self.check_related_eliminations(transaction)

        # 3. 验证金额合理性
        amount_check = self.validate_elimination_amount(transaction)

        return {
            'suggestions': similar_eliminations,
            'warnings': related_eliminations,
            'amount_validation': amount_check
        }

    def suggest_on_workpaper_edit(self, workpaper_id: str, cell_ref: str,
                                  new_value: Any) -> Dict:
        """编辑底稿单元格时的建议"""

        # 1. 检查是否破坏勾稽关系
        reconciliation_check = self.check_reconciliation_impact(
            workpaper_id, cell_ref, new_value
        )

        # 2. 检查是否偏离预期范围
        range_check = self.check_value_range(cell_ref, new_value)

        # 3. 提供历史参考值
        historical_values = self.get_historical_cell_values(cell_ref)

        return {
            'reconciliation_warning': reconciliation_check,
            'range_warning': range_check,
            'historical_reference': historical_values
        }
```

### 6.2 撤销与版本控制

```python
class VersionControl:
    """版本控制 - 支持撤销和恢复"""

    def save_snapshot(self, entity_type: str, entity_id: str,
                     description: str = None):
        """保存快照"""

        snapshot = {
            'snapshot_id': str(uuid.uuid4()),
            'entity_type': entity_type,
            'entity_id': entity_id,
            'snapshot_data': self.get_entity_data(entity_type, entity_id),
            'created_by': current_user.name,
            'created_at': datetime.now().isoformat(),
            'description': description or '自动保存'
        }

        self.save_snapshot_to_db(snapshot)
        return snapshot['snapshot_id']

    def undo_last_change(self, entity_type: str, entity_id: str) -> Dict:
        """撤销最后一次修改"""

        # 1. 获取上一个快照
        previous_snapshot = self.get_previous_snapshot(entity_type, entity_id)

        if not previous_snapshot:
            return {
                'success': False,
                'error': '没有可撤销的版本'
            }

        # 2. 恢复数据
        self.restore_from_snapshot(previous_snapshot)

        # 3. 记录撤销操作
        self.log_undo_operation(entity_type, entity_id, previous_snapshot)

        return {
            'success': True,
            'message': '已撤销到上一版本',
            'snapshot_id': previous_snapshot['snapshot_id']
        }

    def compare_versions(self, snapshot_id_1: str, snapshot_id_2: str) -> Dict:
        """比较两个版本的差异"""

        snapshot1 = self.get_snapshot(snapshot_id_1)
        snapshot2 = self.get_snapshot(snapshot_id_2)

        differences = self._diff_snapshots(snapshot1, snapshot2)

        return {
            'snapshot1_info': {
                'id': snapshot1['snapshot_id'],
                'created_at': snapshot1['created_at'],
                'created_by': snapshot1['created_by']
            },
            'snapshot2_info': {
                'id': snapshot2['snapshot_id'],
                'created_at': snapshot2['created_at'],
                'created_by': snapshot2['created_by']
            },
            'differences': differences
        }
```

---

## 七、实施建议

### 7.1 分阶段实施

```
Phase 1: 基础手动功能 (2周)
├─ 底稿Excel编辑器
├─ 批注系统
├─ 基础权限控制
└─ 修改日志

Phase 2: 高级手动功能 (2周)
├─ 抵消分录手动编辑
├─ 科目映射手动修正
├─ 复核流程
└─ 审计追踪

Phase 3: 智能辅助 (2周)
├─ 智能建议
├─ 异常检测
├─ 版本控制
└─ 撤销/恢复

Phase 4: 用户体验优化 (1周)
├─ 界面优化
├─ 快捷操作
├─ 批量处理
└─ 导出功能
```

### 7.2 用户培训要点

```
审计员培训:
├─ 如何编辑底稿
├─ 如何添加附件和说明
├─ 如何响应复核意见
└─ 权限范围说明

项目经理培训:
├─ 如何复核和批注
├─ 如何调整抵消分录
├─ 如何管理审计组
└─ 如何查看审计日志

合伙人培训:
├─ 最终审批流程
├─ 审计报告签字
├─ 质量控制要点
└─ 风险管理
```

---

## 八、总结

### 核心设计理念
```
自动化 + 手动控制 = 高效 + 高质量

✅ 自动化: 处理重复性工作,提高效率
✅ 手动控制: 保留专业判断,保证质量
✅ AI辅助: 提供建议和风险提示
✅ 审计追踪: 记录所有关键操作
✅ 权限分级: 确保操作安全合规
```

### 关键原则
```
1. 默认自动,允许覆盖 - 系统先自动处理,用户可手动调整
2. 自动可见,手动可溯 - 自动化过程透明,手动操作可追踪
3. 关键人工,常规自动 - 重要判断人工,日常工作自动
4. 辅助决策,人有终权 - AI提供建议,人拥有最终决定权
```

### 实施优先级
```
P0 (必须):
├─ 底稿手动编辑
├─ 抵消分录手动调整
├─ 复核批注
└─ 基础权限控制

P1 (重要):
├─ 科目映射修正
├─ 审计追踪日志
├─ 版本控制
└─ 智能建议

P2 (增强):
├─ 批量操作
├─ 高级搜索
├─ 数据对比
└─ 自定义模板
```

---

**方案制定**: Claude Code
**适用系统**: DAP v2.0 审计底稿与合并报表系统
**设计理念**: 平衡自动化与专业判断,确保审计质量
**核心价值**: 效率提升 + 质量保证 + 风险可控
