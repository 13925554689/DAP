# DAP系统改进方案 - 集团多层级合并报表功能

## 📋 需求分析

### 用户提出的3个核心需求

**1. 项目管理增强 - 多公司层级结构**
- 同一项目下支持多个公司(母子公司/投资公司/控股公司)
- 支持多层级结构(至少6层)
- 为未来合并报表功能做数据基础准备

**2. 合并报表功能**
- 实现集团层面的合并财务报表
- 支持母子公司数据自动抵销
- 跨层级数据聚合和合并

**3. 人机交互 - 自然语言查询**
- 支持任意格式的自然语言查询
- 涵盖凭证、科目、数据等所有查询需求
- 无特定格式要求,智能理解用户意图

---

## 🎯 总体解决方案

### 方案架构图

```
┌─────────────────────────────────────────────────────────┐
│               用户界面层 (GUI改进)                        │
│  ┌──────────────┬──────────────┬──────────────┐         │
│  │ 项目管理界面  │ 公司层级管理  │ 合并报表界面 │         │
│  │  - 项目列表   │  - 树形结构   │  - 报表选择  │         │
│  │  - 创建/编辑  │  - 拖拽调整   │  - 参数设置  │         │
│  └──────────────┴──────────────┴──────────────┘         │
│  ┌────────────────────────────────────────────┐         │
│  │         自然语言查询界面                     │         │
│  │  - 输入框 + 智能提示                        │         │
│  │  - 历史记录 + 快捷查询                       │         │
│  └────────────────────────────────────────────┘         │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│            业务逻辑层 (新增功能模块)                      │
│  ┌──────────────┬──────────────┬──────────────┐         │
│  │集团层级管理器 │ 合并报表引擎  │ NL查询引擎   │         │
│  │- 层级CRUD    │ - 数据合并    │ - 意图识别   │         │
│  │- 持股计算    │ - 抵销处理    │ - SQL生成    │         │
│  │- 关系维护    │ - 少数权益    │ - 结果格式化  │         │
│  └──────────────┴──────────────┴──────────────┘         │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│              数据层 (数据库Schema扩展)                    │
│  ┌──────────────────────────────────────────┐           │
│  │ projects (项目表)                        │           │
│  │  - project_id, project_name, ...        │           │
│  └──────────────────────────────────────────┘           │
│  ┌──────────────────────────────────────────┐           │
│  │ entities (公司实体表) - 新增               │           │
│  │  - entity_id, entity_name, entity_code   │           │
│  │  - parent_entity_id, level, hierarchy     │           │
│  │  - project_id (外键)                      │           │
│  └──────────────────────────────────────────┘           │
│  ┌──────────────────────────────────────────┐           │
│  │ entity_relationships (层级关系表) - 新增   │           │
│  │  - parent_id, child_id, relationship_type │           │
│  │  - ownership_percentage, control_type     │           │
│  └──────────────────────────────────────────┘           │
│  ┌──────────────────────────────────────────┐           │
│  │ consolidation_adjustments (抵销分录) - 新增│           │
│  │  - adjustment_id, period, entity_pair     │           │
│  │  - adjustment_type, amount, description   │           │
│  └──────────────────────────────────────────┘           │
│  ┌──────────────────────────────────────────┐           │
│  │ fact_vouchers/fact_entries (凭证/分录)    │           │
│  │  - 增加 entity_id 字段关联                │           │
│  └──────────────────────────────────────────┘           │
└─────────────────────────────────────────────────────────┘
```

---

## 📊 详细设计方案

### 一、数据库Schema设计

#### 1.1 新增表结构

```sql
-- 1. 公司实体表 (entities)
CREATE TABLE IF NOT EXISTS entities (
    entity_id INTEGER PRIMARY KEY AUTOINCREMENT,
    entity_code TEXT NOT NULL UNIQUE,           -- 公司编码
    entity_name TEXT NOT NULL,                  -- 公司名称
    entity_type TEXT,                           -- 公司类型: 母公司/子公司/孙公司
    project_id TEXT NOT NULL,                   -- 所属项目ID
    parent_entity_id INTEGER,                   -- 父公司ID (自关联)
    level INTEGER DEFAULT 1,                    -- 层级: 1=母公司, 2=子公司, ...
    hierarchy_path TEXT,                        -- 层级路径: 1.2.3
    ownership_percentage REAL DEFAULT 100.0,    -- 持股比例
    control_type TEXT,                          -- 控制类型: 全资/控股/参股
    industry TEXT,                              -- 所属行业
    registration_no TEXT,                       -- 注册号/统一社会信用代码
    legal_representative TEXT,                  -- 法定代表人
    establish_date DATE,                        -- 成立日期
    registered_capital REAL,                    -- 注册资本
    address TEXT,                               -- 注册地址
    business_scope TEXT,                        -- 经营范围
    status TEXT DEFAULT 'active',               -- 状态: active/inactive
    fiscal_year_end TEXT,                       -- 会计年度结束月日: 12-31
    currency TEXT DEFAULT 'CNY',                -- 记账本位币
    tax_number TEXT,                            -- 纳税人识别号
    is_consolidated BOOLEAN DEFAULT 1,          -- 是否纳入合并范围
    notes TEXT,                                 -- 备注
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    created_by TEXT,

    FOREIGN KEY (project_id) REFERENCES projects(project_id),
    FOREIGN KEY (parent_entity_id) REFERENCES entities(entity_id)
);

-- 索引
CREATE INDEX idx_entities_project ON entities(project_id);
CREATE INDEX idx_entities_parent ON entities(parent_entity_id);
CREATE INDEX idx_entities_level ON entities(level);
CREATE INDEX idx_entities_code ON entities(entity_code);

-- 2. 实体关系表 (entity_relationships)
CREATE TABLE IF NOT EXISTS entity_relationships (
    relationship_id INTEGER PRIMARY KEY AUTOINCREMENT,
    parent_entity_id INTEGER NOT NULL,          -- 母公司ID
    child_entity_id INTEGER NOT NULL,           -- 子公司ID
    relationship_type TEXT NOT NULL,            -- 关系类型: 子公司/联营/合营
    ownership_percentage REAL NOT NULL,         -- 持股比例
    voting_rights_percentage REAL,              -- 表决权比例
    control_type TEXT,                          -- 控制类型: 控制/共同控制/重大影响
    acquisition_date DATE,                      -- 取得日期
    acquisition_cost REAL,                      -- 投资成本
    fair_value_at_acquisition REAL,             -- 购买日公允价值
    goodwill REAL,                              -- 商誉
    investment_account TEXT,                    -- 投资科目编码
    equity_method BOOLEAN DEFAULT 0,            -- 是否权益法核算
    consolidation_method TEXT,                  -- 合并方法: 全面/比例/权益
    effective_date DATE,                        -- 生效日期
    expiry_date DATE,                           -- 失效日期
    is_active BOOLEAN DEFAULT 1,                -- 是否有效
    notes TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    FOREIGN KEY (parent_entity_id) REFERENCES entities(entity_id),
    FOREIGN KEY (child_entity_id) REFERENCES entities(entity_id),
    UNIQUE(parent_entity_id, child_entity_id, effective_date)
);

CREATE INDEX idx_relationships_parent ON entity_relationships(parent_entity_id);
CREATE INDEX idx_relationships_child ON entity_relationships(child_entity_id);

-- 3. 内部交易表 (intercompany_transactions)
CREATE TABLE IF NOT EXISTS intercompany_transactions (
    transaction_id INTEGER PRIMARY KEY AUTOINCREMENT,
    transaction_date DATE NOT NULL,             -- 交易日期
    seller_entity_id INTEGER NOT NULL,          -- 销售方公司ID
    buyer_entity_id INTEGER NOT NULL,           -- 购买方公司ID
    transaction_type TEXT NOT NULL,             -- 交易类型: 销售/采购/服务/租赁/借款/担保
    subject_matter TEXT,                        -- 交易标的
    amount REAL NOT NULL,                       -- 交易金额
    currency TEXT DEFAULT 'CNY',
    seller_voucher_id INTEGER,                  -- 销售方凭证ID
    buyer_voucher_id INTEGER,                   -- 购买方凭证ID
    seller_account TEXT,                        -- 销售方科目
    buyer_account TEXT,                         -- 购买方科目
    unrealized_profit REAL DEFAULT 0,           -- 未实现内部利润
    elimination_needed BOOLEAN DEFAULT 1,       -- 是否需要抵销
    fiscal_period TEXT,                         -- 会计期间
    description TEXT,                           -- 交易描述
    notes TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    FOREIGN KEY (seller_entity_id) REFERENCES entities(entity_id),
    FOREIGN KEY (buyer_entity_id) REFERENCES entities(entity_id),
    FOREIGN KEY (seller_voucher_id) REFERENCES fact_vouchers(voucher_id),
    FOREIGN KEY (buyer_voucher_id) REFERENCES fact_vouchers(voucher_id)
);

CREATE INDEX idx_ic_trans_date ON intercompany_transactions(transaction_date);
CREATE INDEX idx_ic_trans_seller ON intercompany_transactions(seller_entity_id);
CREATE INDEX idx_ic_trans_buyer ON intercompany_transactions(buyer_entity_id);
CREATE INDEX idx_ic_trans_period ON intercompany_transactions(fiscal_period);

-- 4. 合并抵销分录表 (consolidation_adjustments)
CREATE TABLE IF NOT EXISTS consolidation_adjustments (
    adjustment_id INTEGER PRIMARY KEY AUTOINCREMENT,
    consolidation_period TEXT NOT NULL,         -- 合并期间
    adjustment_type TEXT NOT NULL,              -- 抵销类型: 内部交易/内部债权债务/未实现利润/投资收益
    adjustment_category TEXT,                   -- 抵销分类: 同级/上下级
    entity_pair TEXT,                           -- 涉及实体对: entity1_id,entity2_id
    reference_transaction_id INTEGER,           -- 关联内部交易ID
    debit_account TEXT NOT NULL,                -- 借方科目
    credit_account TEXT NOT NULL,               -- 贷方科目
    amount REAL NOT NULL,                       -- 抵销金额
    description TEXT,                           -- 抵销说明
    auto_generated BOOLEAN DEFAULT 0,           -- 是否自动生成
    is_manual BOOLEAN DEFAULT 0,                -- 是否手工调整
    approved BOOLEAN DEFAULT 0,                 -- 是否审核
    approved_by TEXT,
    approved_at TIMESTAMP,
    notes TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    created_by TEXT,

    FOREIGN KEY (reference_transaction_id) REFERENCES intercompany_transactions(transaction_id)
);

CREATE INDEX idx_consol_adj_period ON consolidation_adjustments(consolidation_period);
CREATE INDEX idx_consol_adj_type ON consolidation_adjustments(adjustment_type);

-- 5. 合并报表元数据表 (consolidation_metadata)
CREATE TABLE IF NOT EXISTS consolidation_metadata (
    consolidation_id INTEGER PRIMARY KEY AUTOINCREMENT,
    project_id TEXT NOT NULL,                   -- 项目ID
    consolidation_period TEXT NOT NULL,         -- 合并期间
    parent_entity_id INTEGER NOT NULL,          -- 母公司ID
    consolidation_scope TEXT,                   -- 合并范围: JSON array of entity_ids
    consolidation_method TEXT DEFAULT 'full',   -- 合并方法: full/proportional
    exchange_rate_date DATE,                    -- 汇率日期
    exchange_rates TEXT,                        -- 汇率表: JSON
    minority_interest_method TEXT DEFAULT 'fair_value', -- 少数股东权益计量: fair_value/proportional
    goodwill_impairment REAL DEFAULT 0,         -- 商誉减值
    adjustment_count INTEGER DEFAULT 0,          -- 抵销分录数量
    status TEXT DEFAULT 'draft',                -- 状态: draft/in_progress/completed/approved
    report_generated BOOLEAN DEFAULT 0,          -- 是否已生成报表
    report_path TEXT,                           -- 报表文件路径
    generated_at TIMESTAMP,
    generated_by TEXT,
    approved_at TIMESTAMP,
    approved_by TEXT,
    notes TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    FOREIGN KEY (project_id) REFERENCES projects(project_id),
    FOREIGN KEY (parent_entity_id) REFERENCES entities(entity_id),
    UNIQUE(project_id, consolidation_period, parent_entity_id)
);

CREATE INDEX idx_consol_meta_project ON consolidation_metadata(project_id);
CREATE INDEX idx_consol_meta_period ON consolidation_metadata(consolidation_period);
```

#### 1.2 现有表修改

```sql
-- 修改 fact_vouchers 表,增加 entity_id
ALTER TABLE fact_vouchers ADD COLUMN entity_id INTEGER;
CREATE INDEX idx_vouchers_entity ON fact_vouchers(entity_id);

-- 修改 fact_entries 表,增加 entity_id
ALTER TABLE fact_entries ADD COLUMN entity_id INTEGER;
CREATE INDEX idx_entries_entity ON fact_entries(entity_id);

-- 修改 dim_accounts 表,增加账套支持
ALTER TABLE dim_accounts ADD COLUMN entity_id INTEGER;
CREATE INDEX idx_accounts_entity ON dim_accounts(entity_id);
```

---

### 二、GUI界面设计

#### 2.1 项目管理界面升级

**现有界面改进:**

```python
# dap_launcher.py 中的项目设置区域升级

def create_project_management_tab(self, parent):
    """创建项目管理标签页 - 全新设计"""
    project_frame = ttk.Frame(parent, padding="10")
    parent.add(project_frame, text="项目管理")

    # 左侧: 项目列表
    left_pane = ttk.Frame(project_frame)
    left_pane.grid(row=0, column=0, sticky="nsew", padx=(0,5))

    # 项目列表树形控件
    project_tree_frame = ttk.LabelFrame(left_pane, text="项目列表", padding="5")
    project_tree_frame.pack(fill="both", expand=True)

    self.project_tree = ttk.Treeview(
        project_tree_frame,
        columns=("项目编码", "客户", "年度", "状态"),
        show="tree headings"
    )
    self.project_tree.heading("#0", text="项目名称")
    self.project_tree.heading("项目编码", text="编码")
    self.project_tree.heading("客户", text="客户")
    self.project_tree.heading("年度", text="年度")
    self.project_tree.heading("状态", text="状态")

    self.project_tree.pack(fill="both", expand=True)

    # 项目操作按钮
    btn_frame = ttk.Frame(left_pane)
    btn_frame.pack(fill="x", pady=5)

    ttk.Button(btn_frame, text="➕ 新建项目",
              command=self.create_new_project).pack(side="left", padx=2)
    ttk.Button(btn_frame, text="✏️ 编辑",
              command=self.edit_project).pack(side="left", padx=2)
    ttk.Button(btn_frame, text="🗑️ 删除",
              command=self.delete_project).pack(side="left", padx=2)
    ttk.Button(btn_frame, text="🔄 刷新",
              command=self.refresh_projects).pack(side="left", padx=2)

    # 右侧: 公司层级管理
    right_pane = ttk.Frame(project_frame)
    right_pane.grid(row=0, column=1, sticky="nsew", padx=(5,0))

    # 公司层级树形结构
    entity_frame = ttk.LabelFrame(right_pane, text="公司组织结构", padding="5")
    entity_frame.pack(fill="both", expand=True)

    # 工具栏
    toolbar = ttk.Frame(entity_frame)
    toolbar.pack(fill="x", pady=(0,5))

    ttk.Button(toolbar, text="➕ 添加公司",
              command=self.add_entity).pack(side="left", padx=2)
    ttk.Button(toolbar, text="➕ 添加子公司",
              command=self.add_sub_entity).pack(side="left", padx=2)
    ttk.Button(toolbar, text="✏️ 编辑关系",
              command=self.edit_relationship).pack(side="left", padx=2)
    ttk.Button(toolbar, text="📊 查看层级图",
              command=self.view_hierarchy_chart).pack(side="left", padx=2)

    # 树形控件
    self.entity_tree = ttk.Treeview(
        entity_frame,
        columns=("编码", "类型", "持股比例", "层级"),
        show="tree headings"
    )
    self.entity_tree.heading("#0", text="公司名称")
    self.entity_tree.heading("编码", text="公司编码")
    self.entity_tree.heading("类型", text="公司类型")
    self.entity_tree.heading("持股比例", text="持股比例%")
    self.entity_tree.heading("层级", text="层级")

    # 滚动条
    scrollbar = ttk.Scrollbar(entity_frame, orient="vertical",
                             command=self.entity_tree.yview)
    self.entity_tree.configure(yscrollcommand=scrollbar.set)

    self.entity_tree.pack(side="left", fill="both", expand=True)
    scrollbar.pack(side="right", fill="y")

    # 双击事件
    self.entity_tree.bind("<Double-1>", self.on_entity_double_click)

    # 右键菜单
    self.entity_context_menu = tk.Menu(self.entity_tree, tearoff=0)
    self.entity_context_menu.add_command(label="查看详情",
                                        command=self.view_entity_detail)
    self.entity_context_menu.add_command(label="编辑信息",
                                        command=self.edit_entity)
    self.entity_context_menu.add_separator()
    self.entity_context_menu.add_command(label="添加子公司",
                                        command=self.add_sub_entity)
    self.entity_context_menu.add_command(label="设置持股关系",
                                        command=self.set_ownership)
    self.entity_context_menu.add_separator()
    self.entity_context_menu.add_command(label="查看财务数据",
                                        command=self.view_entity_financials)
    self.entity_context_menu.add_command(label="查看内部交易",
                                        command=self.view_intercompany_trans)

    self.entity_tree.bind("<Button-3>", self.show_entity_context_menu)

    # 底部: 项目详情
    detail_frame = ttk.LabelFrame(right_pane, text="选中信息", padding="5")
    detail_frame.pack(fill="x", pady=(5,0))

    self.entity_detail_text = scrolledtext.ScrolledText(
        detail_frame, height=8, state='disabled'
    )
    self.entity_detail_text.pack(fill="both", expand=True)

    # 配置网格权重
    project_frame.columnconfigure(0, weight=1)
    project_frame.columnconfigure(1, weight=2)
    project_frame.rowconfigure(0, weight=1)
```

#### 2.2 合并报表界面

```python
def create_consolidation_tab(self, parent):
    """创建合并报表标签页 - 新增"""
    consol_frame = ttk.Frame(parent, padding="10")
    parent.add(consol_frame, text="合并报表")

    # 顶部: 合并参数设置
    param_frame = ttk.LabelFrame(consol_frame, text="合并参数设置", padding="10")
    param_frame.pack(fill="x", pady=(0,10))

    # 第一行: 项目和期间选择
    row1 = ttk.Frame(param_frame)
    row1.pack(fill="x", pady=2)

    ttk.Label(row1, text="项目:").pack(side="left")
    self.consol_project_var = tk.StringVar()
    ttk.Combobox(row1, textvariable=self.consol_project_var,
                state="readonly", width=30).pack(side="left", padx=5)

    ttk.Label(row1, text="合并期间:").pack(side="left", padx=(20,0))
    self.consol_period_var = tk.StringVar(value="2024")
    ttk.Entry(row1, textvariable=self.consol_period_var,
             width=15).pack(side="left", padx=5)

    # 第二行: 母公司和合并范围
    row2 = ttk.Frame(param_frame)
    row2.pack(fill="x", pady=2)

    ttk.Label(row2, text="母公司:").pack(side="left")
    self.consol_parent_var = tk.StringVar()
    ttk.Combobox(row2, textvariable=self.consol_parent_var,
                state="readonly", width=30).pack(side="left", padx=5)

    ttk.Label(row2, text="合并范围:").pack(side="left", padx=(20,0))
    ttk.Button(row2, text="📋 选择公司",
              command=self.select_consolidation_scope).pack(side="left", padx=5)

    self.consol_scope_label = ttk.Label(row2, text="未选择", foreground="gray")
    self.consol_scope_label.pack(side="left", padx=5)

    # 第三行: 合并方法和其他选项
    row3 = ttk.Frame(param_frame)
    row3.pack(fill="x", pady=2)

    ttk.Label(row3, text="合并方法:").pack(side="left")
    self.consol_method_var = tk.StringVar(value="full")
    ttk.Radiobutton(row3, text="完全合并", variable=self.consol_method_var,
                   value="full").pack(side="left", padx=5)
    ttk.Radiobutton(row3, text="比例合并", variable=self.consol_method_var,
                   value="proportional").pack(side="left", padx=5)

    self.auto_eliminate_var = tk.BooleanVar(value=True)
    ttk.Checkbutton(row3, text="自动生成抵销分录",
                   variable=self.auto_eliminate_var).pack(side="left", padx=(20,0))

    # 中部: 抵销分录管理
    adjustment_frame = ttk.LabelFrame(consol_frame, text="抵销分录", padding="5")
    adjustment_frame.pack(fill="both", expand=True, pady=(0,10))

    # 工具栏
    adj_toolbar = ttk.Frame(adjustment_frame)
    adj_toolbar.pack(fill="x", pady=(0,5))

    ttk.Button(adj_toolbar, text="🔄 自动识别内部交易",
              command=self.auto_detect_intercompany).pack(side="left", padx=2)
    ttk.Button(adj_toolbar, text="➕ 手工添加抵销",
              command=self.add_manual_adjustment).pack(side="left", padx=2)
    ttk.Button(adj_toolbar, text="✏️ 编辑",
              command=self.edit_adjustment).pack(side="left", padx=2)
    ttk.Button(adj_toolbar, text="🗑️ 删除",
              command=self.delete_adjustment).pack(side="left", padx=2)
    ttk.Button(adj_toolbar, text="📥 导入抵销模板",
              command=self.import_adjustments).pack(side="left", padx=2)

    # 抵销分录列表
    self.adjustment_tree = ttk.Treeview(
        adjustment_frame,
        columns=("类型", "公司对", "借方科目", "贷方科目", "金额", "说明"),
        show="headings",
        height=10
    )

    headers = [("类型", 100), ("公司对", 200), ("借方科目", 120),
               ("贷方科目", 120), ("金额", 100), ("说明", 250)]
    for col, width in headers:
        self.adjustment_tree.heading(col, text=col)
        self.adjustment_tree.column(col, width=width)

    adj_scroll_y = ttk.Scrollbar(adjustment_frame, orient="vertical",
                                command=self.adjustment_tree.yview)
    adj_scroll_x = ttk.Scrollbar(adjustment_frame, orient="horizontal",
                                command=self.adjustment_tree.xview)
    self.adjustment_tree.configure(yscrollcommand=adj_scroll_y.set,
                                   xscrollcommand=adj_scroll_x.set)

    self.adjustment_tree.grid(row=1, column=0, sticky="nsew")
    adj_scroll_y.grid(row=1, column=1, sticky="ns")
    adj_scroll_x.grid(row=2, column=0, sticky="ew")

    adjustment_frame.columnconfigure(0, weight=1)
    adjustment_frame.rowconfigure(1, weight=1)

    # 底部: 操作按钮
    btn_frame = ttk.Frame(consol_frame)
    btn_frame.pack(fill="x")

    ttk.Button(btn_frame, text="🔍 预览合并结果",
              command=self.preview_consolidation,
              style='Accent.TButton', width=20).pack(side="left", padx=5)
    ttk.Button(btn_frame, text="📊 生成合并报表",
              command=self.generate_consolidation_report,
              style='Accent.TButton', width=20).pack(side="left", padx=5)
    ttk.Button(btn_frame, text="💾 保存合并方案",
              command=self.save_consolidation_scheme,
              width=18).pack(side="left", padx=5)
    ttk.Button(btn_frame, text="📜 查看历史合并",
              command=self.view_consolidation_history,
              width=18).pack(side="left", padx=5)
```

#### 2.3 自然语言查询界面

```python
def create_nl_query_tab(self, parent):
    """创建自然语言查询标签页 - 新增"""
    nl_frame = ttk.Frame(parent, padding="10")
    parent.add(nl_frame, text="智能查询")

    nl_frame.columnconfigure(0, weight=1)
    nl_frame.rowconfigure(1, weight=1)

    # 顶部: 查询输入区
    input_frame = ttk.LabelFrame(nl_frame, text="输入查询 (支持自然语言)", padding="10")
    input_frame.grid(row=0, column=0, sticky="ew", pady=(0,10))
    input_frame.columnconfigure(0, weight=1)

    # 查询输入框
    self.nl_query_text = tk.Text(input_frame, height=4, wrap=tk.WORD,
                                 font=('Microsoft YaHei', 10))
    self.nl_query_text.grid(row=0, column=0, sticky="ew", pady=(0,5))

    # 智能提示标签
    hint_label = ttk.Label(
        input_frame,
        text="💡 示例: \"查找2024年北京公司的所有管理费用凭证\" / \"对比母子公司的应收账款\" / \"显示集团内部采购交易\"",
        font=('Arial', 8),
        foreground='gray'
    )
    hint_label.grid(row=1, column=0, sticky="w")

    # 快捷查询按钮
    quick_frame = ttk.Frame(input_frame)
    quick_frame.grid(row=2, column=0, sticky="ew", pady=(5,0))

    quick_queries = [
        ("📋 所有凭证", "显示所有凭证"),
        ("💰 科目余额", "查询科目余额表"),
        ("🏢 公司对比", "对比各公司财务数据"),
        ("🔗 内部交易", "显示内部交易明细"),
        ("📊 合并报表", "查看合并财务报表"),
        ("⚠️ 异常数据", "查找异常或可疑数据")
    ]

    for i, (text, query) in enumerate(quick_queries):
        ttk.Button(
            quick_frame,
            text=text,
            width=15,
            command=lambda q=query: self.set_nl_query(q)
        ).grid(row=i//3, column=i%3, padx=2, pady=2, sticky="ew")

    for i in range(3):
        quick_frame.columnconfigure(i, weight=1)

    # 查询按钮
    query_btn = ttk.Button(
        input_frame,
        text="🔍 智能查询",
        command=self.execute_nl_query,
        style='Accent.TButton'
    )
    query_btn.grid(row=3, column=0, pady=(10,0))

    # 中部: 查询结果显示
    result_frame = ttk.LabelFrame(nl_frame, text="查询结果", padding="5")
    result_frame.grid(row=1, column=0, sticky="nsew")
    result_frame.columnconfigure(0, weight=1)
    result_frame.rowconfigure(0, weight=1)

    # 创建Notebook用于多种结果展示
    self.result_notebook = ttk.Notebook(result_frame)
    self.result_notebook.grid(row=0, column=0, sticky="nsew")

    # 表格视图
    table_frame = ttk.Frame(self.result_notebook)
    self.result_notebook.add(table_frame, text="📊 表格")

    self.nl_result_tree = ttk.Treeview(table_frame, show="headings")
    nl_scroll_y = ttk.Scrollbar(table_frame, orient="vertical",
                               command=self.nl_result_tree.yview)
    nl_scroll_x = ttk.Scrollbar(table_frame, orient="horizontal",
                               command=self.nl_result_tree.xview)
    self.nl_result_tree.configure(yscrollcommand=nl_scroll_y.set,
                                   xscrollcommand=nl_scroll_x.set)

    self.nl_result_tree.grid(row=0, column=0, sticky="nsew")
    nl_scroll_y.grid(row=0, column=1, sticky="ns")
    nl_scroll_x.grid(row=1, column=0, sticky="ew")

    table_frame.columnconfigure(0, weight=1)
    table_frame.rowconfigure(0, weight=1)

    # 文本视图
    text_frame = ttk.Frame(self.result_notebook)
    self.result_notebook.add(text_frame, text="📝 文本")

    self.nl_result_text = scrolledtext.ScrolledText(
        text_frame, wrap=tk.WORD, state='disabled'
    )
    self.nl_result_text.pack(fill="both", expand=True)

    # 统计视图
    stats_frame = ttk.Frame(self.result_notebook)
    self.result_notebook.add(stats_frame, text="📈 统计")

    self.nl_stats_text = scrolledtext.ScrolledText(
        stats_frame, wrap=tk.WORD, state='disabled', font=('Courier New', 9)
    )
    self.nl_stats_text.pack(fill="both", expand=True)

    # 底部: 操作栏
    action_frame = ttk.Frame(nl_frame)
    action_frame.grid(row=2, column=0, sticky="ew", pady=(5,0))

    ttk.Button(action_frame, text="📤 导出结果",
              command=self.export_nl_result).pack(side="left", padx=2)
    ttk.Button(action_frame, text="💾 保存查询",
              command=self.save_nl_query).pack(side="left", padx=2)
    ttk.Button(action_frame, text="📜 查询历史",
              command=self.view_query_history).pack(side="left", padx=2)
    ttk.Button(action_frame, text="🔄 清空",
              command=self.clear_nl_result).pack(side="left", padx=2)

    # 状态信息
    self.nl_status_var = tk.StringVar(value="就绪")
    status_label = ttk.Label(action_frame, textvariable=self.nl_status_var,
                            foreground='blue')
    status_label.pack(side="right", padx=5)
```

---

### 三、后端业务逻辑设计

#### 3.1 集团层级管理器 (GroupHierarchyManager)

```python
# layer3/group_hierarchy_manager.py

class GroupHierarchyManager:
    """集团层级管理器 - 管理多层级公司结构"""

    def __init__(self, db_path: str):
        self.db_path = db_path
        self.conn = sqlite3.connect(db_path)

    def create_entity(self, project_id: str, entity_data: Dict) -> int:
        """创建公司实体"""
        # 参数验证和SQL插入逻辑
        pass

    def add_subsidiary(self, parent_id: int, subsidiary_data: Dict,
                      ownership_pct: float) -> int:
        """添加子公司"""
        # 1. 创建实体
        # 2. 建立关系
        # 3. 计算层级
        # 4. 更新hierarchy_path
        pass

    def calculate_hierarchy_path(self, entity_id: int) -> str:
        """计算层级路径"""
        # 递归查找父级,生成path: 1.2.5.8
        pass

    def get_hierarchy_tree(self, project_id: str, root_entity_id: int = None) -> Dict:
        """获取层级树结构"""
        # 返回树形JSON结构,用于GUI展示
        pass

    def get_all_descendants(self, entity_id: int) -> List[int]:
        """获取所有下级公司(递归)"""
        pass

    def get_consolidation_scope(self, parent_id: int,
                               include_criteria: Dict = None) -> List[int]:
        """获取合并范围"""
        # 根据持股比例、控制类型等筛选纳入合并的子公司
        pass

    def calculate_effective_ownership(self, parent_id: int,
                                     target_id: int) -> float:
        """计算实际持股比例(考虑多层级)"""
        # 例如: A持B 60%, B持C 80%, 则A对C实际持股 60%*80%=48%
        pass

    def validate_circular_reference(self, parent_id: int, child_id: int) -> bool:
        """验证是否有循环引用"""
        pass
```

#### 3.2 合并报表引擎 (ConsolidationEngine)

```python
# layer3/consolidation_engine.py

class ConsolidationEngine:
    """合并报表引擎 - 核心合并逻辑"""

    def __init__(self, db_path: str):
        self.db_path = db_path
        self.hierarchy_mgr = GroupHierarchyManager(db_path)

    def generate_consolidated_report(self,
                                     parent_entity_id: int,
                                     period: str,
                                     report_type: str = 'balance_sheet',
                                     options: Dict = None) -> Dict:
        """生成合并报表主流程"""

        # 1. 确定合并范围
        scope_entities = self._determine_consolidation_scope(
            parent_entity_id, period, options
        )

        # 2. 收集各公司财务数据
        entity_financials = self._collect_entity_financials(
            scope_entities, period, report_type
        )

        # 3. 识别内部交易
        intercompany_trans = self._identify_intercompany_transactions(
            scope_entities, period
        )

        # 4. 生成抵销分录
        adjustments = self._generate_elimination_entries(
            intercompany_trans, entity_financials, options
        )

        # 5. 执行合并
        consolidated_data = self._perform_consolidation(
            entity_financials, adjustments, options
        )

        # 6. 计算少数股东权益
        minority_interest = self._calculate_minority_interest(
            scope_entities, consolidated_data, options
        )

        # 7. 生成报表
        report = self._format_consolidated_report(
            consolidated_data, minority_interest, report_type
        )

        # 8. 保存元数据
        self._save_consolidation_metadata(
            parent_entity_id, period, scope_entities, adjustments
        )

        return report

    def _identify_intercompany_transactions(self, entities: List[int],
                                           period: str) -> pd.DataFrame:
        """识别内部交易 - 智能匹配"""

        # 方法1: 基于交易对手方字段(如果有)
        # 方法2: 基于科目对应关系(应收vs应付)
        # 方法3: 基于金额和日期匹配
        # 方法4: AI辅助识别

        query = """
        SELECT
            v1.entity_id as seller_entity_id,
            v2.entity_id as buyer_entity_id,
            v1.voucher_date as transaction_date,
            e1.debit_amount as seller_amount,
            e2.credit_amount as buyer_amount,
            v1.voucher_id as seller_voucher_id,
            v2.voucher_id as buyer_voucher_id
        FROM fact_vouchers v1
        JOIN fact_entries e1 ON v1.voucher_id = e1.voucher_id
        JOIN fact_vouchers v2 ON v2.entity_id != v1.entity_id
        JOIN fact_entries e2 ON v2.voucher_id = e2.voucher_id
        WHERE v1.entity_id IN ({entity_list})
          AND v2.entity_id IN ({entity_list})
          AND v1.fiscal_year = ?
          AND ABS(e1.debit_amount - e2.credit_amount) < 0.01
          AND ABS(julianday(v1.voucher_date) - julianday(v2.voucher_date)) <= 7
          AND (
              (e1.account_code LIKE '1122%' AND e2.account_code LIKE '2202%')  -- 应收vs应付
              OR (e1.account_code LIKE '1123%' AND e2.account_code LIKE '2203%')
          )
        """
        pass

    def _generate_elimination_entries(self, transactions: pd.DataFrame,
                                     financials: Dict, options: Dict) -> List[Dict]:
        """生成抵销分录"""

        adjustments = []

        # 1. 内部交易抵销
        for _, trans in transactions.iterrows():
            adjustments.append({
                'type': '内部交易抵销',
                'debit_account': trans['seller_account'],
                'credit_account': trans['buyer_account'],
                'amount': trans['amount'],
                'description': f"抵销{trans['seller_entity']}向{trans['buyer_entity']}的内部交易"
            })

        # 2. 内部债权债务抵销
        # SELECT账龄分析,匹配应收应付

        # 3. 未实现内部利润抵销
        # 计算存货/固定资产中的未实现利润

        # 4. 投资收益抵销
        # 长期股权投资 vs 子公司权益

        return adjustments

    def _perform_consolidation(self, entity_financials: Dict,
                              adjustments: List, options: Dict) -> pd.DataFrame:
        """执行合并计算"""

        # 1. 汇总各公司数据
        consolidated = pd.DataFrame()
        for entity_id, data in entity_financials.items():
            if consolidated.empty:
                consolidated = data.copy()
            else:
                # 按科目编码merge并求和
                consolidated = pd.merge(
                    consolidated, data,
                    on='科目编码', how='outer',
                    suffixes=('', f'_entity{entity_id}')
                )
                # 汇总金额列

        # 2. 应用抵销分录
        for adj in adjustments:
            # 借方科目减少, 贷方科目减少
            pass

        return consolidated

    def _calculate_minority_interest(self, entities: List,
                                    consolidated: pd.DataFrame,
                                    options: Dict) -> Dict:
        """计算少数股东权益"""

        minority_equity = {}

        for entity_id in entities:
            ownership = self.hierarchy_mgr.calculate_effective_ownership(
                parent_id, entity_id
            )
            if ownership < 100:
                minority_pct = 100 - ownership
                # 计算该实体的净资产
                entity_equity = ...
                minority_equity[entity_id] = entity_equity * (minority_pct / 100)

        return minority_equity
```

#### 3.3 自然语言查询引擎 (NLQueryEngine)

```python
# layer3/nl_query_engine.py

class NLQueryEngine:
    """自然语言查询引擎"""

    def __init__(self, db_path: str):
        self.db_path = db_path
        self.intent_patterns = self._load_intent_patterns()
        self.entity_extractor = self._init_entity_extractor()

    def process_query(self, query_text: str, context: Dict = None) -> Dict:
        """处理自然语言查询"""

        # 1. 意图识别
        intent = self._identify_intent(query_text)

        # 2. 实体抽取
        entities = self._extract_entities(query_text, context)

        # 3. 生成SQL
        sql = self._generate_sql(intent, entities)

        # 4. 执行查询
        result = self._execute_query(sql)

        # 5. 格式化结果
        formatted = self._format_result(result, intent)

        return {
            'success': True,
            'intent': intent,
            'entities': entities,
            'sql': sql,
            'result': formatted,
            'row_count': len(result)
        }

    def _identify_intent(self, query: str) -> str:
        """识别查询意图"""

        intents = {
            'voucher_query': ['凭证', '记账', '分录', 'voucher'],
            'account_balance': ['余额', '科目', '账目', 'balance'],
            'intercompany': ['内部', '关联', '往来', 'intercompany'],
            'consolidation': ['合并', '汇总', '集团', 'consolidation'],
            'comparison': ['对比', '比较', 'compare', 'vs'],
            'anomaly': ['异常', '可疑', '错误', 'anomaly'],
            'entity_info': ['公司信息', '组织', '机构'],
        }

        scores = {}
        for intent_name, keywords in intents.items():
            score = sum(1 for kw in keywords if kw in query.lower())
            if score > 0:
                scores[intent_name] = score

        if scores:
            return max(scores, key=scores.get)
        return 'general_query'

    def _extract_entities(self, query: str, context: Dict) -> Dict:
        """抽取查询实体"""

        entities = {}

        # 1. 日期/期间
        date_patterns = [
            r'(\d{4})年',
            r'(\d{4})-(\d{2})',
            r'(\d{4})年(\d{1,2})月'
        ]
        for pattern in date_patterns:
            match = re.search(pattern, query)
            if match:
                entities['period'] = match.group(0)
                break

        # 2. 公司名称
        # 查询数据库中的公司列表,模糊匹配
        conn = sqlite3.connect(self.db_path)
        company_names = pd.read_sql(
            "SELECT entity_id, entity_name FROM entities", conn
        )
        conn.close()

        for _, row in company_names.iterrows():
            if row['entity_name'] in query:
                entities['entity'] = row['entity_id']
                entities['entity_name'] = row['entity_name']
                break

        # 3. 科目名称/编码
        account_keywords = re.findall(r'[一-龥]+费用|应收|应付|存货|现金|银行', query)
        if account_keywords:
            entities['account_keyword'] = account_keywords[0]

        # 4. 金额范围
        amount_match = re.search(r'([大小超]于|以上|以下)\s*(\d+(?:,\d{3})*(?:\.\d+)?)\s*(元|万|亿)?', query)
        if amount_match:
            entities['amount_condition'] = amount_match.group(0)

        return entities

    def _generate_sql(self, intent: str, entities: Dict) -> str:
        """生成SQL查询"""

        sql_templates = {
            'voucher_query': """
                SELECT v.voucher_date as 日期,
                       v.voucher_number as 凭证号,
                       e.account_code as 科目编码,
                       a.account_name as 科目名称,
                       e.summary as 摘要,
                       e.debit_amount as 借方金额,
                       e.credit_amount as 贷方金额,
                       ent.entity_name as 公司
                FROM fact_vouchers v
                JOIN fact_entries e ON v.voucher_id = e.voucher_id
                LEFT JOIN dim_accounts a ON e.account_code = a.account_code
                LEFT JOIN entities ent ON v.entity_id = ent.entity_id
                WHERE 1=1
                {period_filter}
                {entity_filter}
                {account_filter}
                ORDER BY v.voucher_date DESC, v.voucher_number
                LIMIT 1000
            """,

            'account_balance': """
                SELECT
                    a.account_code as 科目编码,
                    a.account_name as 科目名称,
                    SUM(CASE WHEN e.debit_amount > 0 THEN e.debit_amount ELSE 0 END) as 借方发生额,
                    SUM(CASE WHEN e.credit_amount > 0 THEN e.credit_amount ELSE 0 END) as 贷方发生额,
                    SUM(e.debit_amount - e.credit_amount) as 余额
                FROM fact_entries e
                JOIN dim_accounts a ON e.account_code = a.account_code
                JOIN fact_vouchers v ON e.voucher_id = v.voucher_id
                WHERE 1=1
                {period_filter}
                {entity_filter}
                GROUP BY a.account_code, a.account_name
                ORDER BY a.account_code
            """,

            'intercompany': """
                SELECT
                    it.transaction_date as 交易日期,
                    e1.entity_name as 销售方,
                    e2.entity_name as 购买方,
                    it.transaction_type as 交易类型,
                    it.amount as 交易金额,
                    it.description as 说明
                FROM intercompany_transactions it
                JOIN entities e1 ON it.seller_entity_id = e1.entity_id
                JOIN entities e2 ON it.buyer_entity_id = e2.entity_id
                WHERE 1=1
                {period_filter}
                ORDER BY it.transaction_date DESC
            """
        }

        # 选择模板
        template = sql_templates.get(intent, sql_templates['voucher_query'])

        # 构建过滤条件
        filters = {}

        if 'period' in entities:
            period = entities['period']
            if len(period) == 4:  # 年份
                filters['period_filter'] = f"AND strftime('%Y', v.voucher_date) = '{period}'"
            else:
                filters['period_filter'] = f"AND v.fiscal_year = '{period}'"
        else:
            filters['period_filter'] = ""

        if 'entity' in entities:
            filters['entity_filter'] = f"AND v.entity_id = {entities['entity']}"
        else:
            filters['entity_filter'] = ""

        if 'account_keyword' in entities:
            keyword = entities['account_keyword']
            filters['account_filter'] = f"AND a.account_name LIKE '%{keyword}%'"
        else:
            filters['account_filter'] = ""

        # 填充模板
        sql = template.format(**filters)

        return sql

    def _execute_query(self, sql: str) -> pd.DataFrame:
        """执行SQL查询"""
        try:
            conn = sqlite3.connect(self.db_path)
            result = pd.read_sql_query(sql, conn)
            conn.close()
            return result
        except Exception as e:
            logger.error(f"查询执行失败: {e}")
            return pd.DataFrame()

    def _format_result(self, df: pd.DataFrame, intent: str) -> Dict:
        """格式化查询结果"""

        if df.empty:
            return {
                'message': '未找到匹配的数据',
                'data': df,
                'stats': {}
            }

        # 生成统计信息
        stats = {
            '记录数': len(df),
            '查询时间': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        }

        # 根据意图生成特定统计
        if intent == 'account_balance':
            if '余额' in df.columns:
                stats['余额合计'] = f"{df['余额'].sum():,.2f}"

        if intent == 'voucher_query':
            if '借方金额' in df.columns:
                stats['借方合计'] = f"{df['借方金额'].sum():,.2f}"
            if '贷方金额' in df.columns:
                stats['贷方合计'] = f"{df['贷方金额'].sum():,.2f}"

        return {
            'message': f'查询成功,找到 {len(df)} 条记录',
            'data': df,
            'stats': stats
        }
```

---

### 四、实施步骤

#### 阶段一: 数据库升级 (2-3天)

1. 创建新表结构
2. 数据迁移脚本
3. 索引优化
4. 测试数据验证

#### 阶段二: 后端功能开发 (5-7天)

1. GroupHierarchyManager实现
2. ConsolidationEngine实现
3. NLQueryEngine实现
4. 单元测试编写

#### 阶段三: GUI界面开发 (4-5天)

1. 项目管理界面升级
2. 合并报表界面开发
3. 智能查询界面开发
4. 界面联调测试

#### 阶段四: 集成测试 (2-3天)

1. 端到端功能测试
2. 性能测试
3. 用户体验优化
4. 文档编写

---

## ⚡ 快速原型方案 (先看效果)

如果您想先看到效果,我建议分步实施:

### 第一步: 基础多公司支持 (1-2天)
- 只添加entities表
- GUI上添加简单的公司管理界面
- 凭证/科目关联entity_id

### 第二步: 简化合并报表 (2-3天)
- 只做数据汇总,暂不做抵销
- 生成简单的合并报表
- 验证多层级结构

### 第三步: 基础NL查询 (2-3天)
- 实现关键词匹配
- 生成基本SQL
- 展示查询结果

### 第四步: 完善功能 (按需)
- 自动抵销
- 智能识别
- 高级查询

---

## 💬 您的意见?

请告诉我:

1. **这个方案是否符合您的需求?**
2. **是否需要调整某些设计?**
3. **想先实现哪个部分?** (完整方案 vs 快速原型)
4. **对于合并报表的抵销规则,有什么特殊要求吗?**
5. **自然语言查询需要支持哪些典型场景?**

我会根据您的反馈调整方案并开始实施! 🚀
